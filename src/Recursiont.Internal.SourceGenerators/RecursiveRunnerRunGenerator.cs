// Copyright Â© Theodore Tsirpanis and Contributors.
// Licensed under the MIT License (MIT).
// See LICENSE in the repository root for more information.

using Microsoft.CodeAnalysis;
using System.CodeDom.Compiler;

namespace Recursiont.Internal.SourceGenerators;

[Generator]
public sealed class RecursiveRunnerRunGenerator : IIncrementalGenerator
{
    // If you want to add support for more parameters extend this list.
    private static readonly (string Numeral, string Ordinal)[] s_numberInfo =
    {
        ("one", "first"),
        ("two", "second"),
        ("three", "third"),
        ("four", "fourth"),
        ("five", "fifth"),
        ("six", "sixth")
    };

    private static void EmitRunMethod(IndentedTextWriter writer, int parameterCount, bool returnsResult)
    {
        EmitXmlDocumentation(writer, parameterCount, returnsResult);

        const string ResultGenericType = "TResult";
        IEnumerable<int> argumentIndices = Enumerable.Range(1, parameterCount);
        IEnumerable<string> argsSequence = argumentIndices.Select(static x => $"T{x}");
        IEnumerable<string> genericParamsSequence = argsSequence;
        if (returnsResult)
        {
            genericParamsSequence = genericParamsSequence.Concat(new[] { ResultGenericType });
        }
        string methodGenericParams = parameterCount > 0 || returnsResult ? $"<{string.Join(", ", genericParamsSequence)}>" : string.Empty;
        string recursiveOpType = returnsResult ? $"RecursiveOp<{ResultGenericType}>" : "RecursiveOp";
        string funcGenericParams = string.Join(", ", argsSequence.Concat(new[] { recursiveOpType }));
        string funcArgumentDefinitions = string.Join(", ", argumentIndices.Select(static x => $"T{x} arg{x}"));
        if (funcArgumentDefinitions.Length > 0)
        {
            funcArgumentDefinitions = $", {funcArgumentDefinitions}";
        }

        string returnType = returnsResult ? ResultGenericType : "void";
        string funcParamName = returnsResult ? "recursiveFunc" : "recursiveAction";
        writer.WriteLine($"[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        using (EnterBlock(writer, $"public static {returnType} Run{methodGenericParams}(Func<{funcGenericParams}> {funcParamName}{funcArgumentDefinitions})"))
        {
            writer.WriteLine($"ArgumentNullExceptionCompat.ThrowIfNull({funcParamName});");
            writer.WriteLine();
            using (EnterBlock(writer, $"using (var ctx = SetupRunnerFrame())"))
            {
                string returnMaybe = returnsResult ? "return " : string.Empty;
                string funcArguments = string.Join(", ", argumentIndices.Select(static x => $"arg{x}"));
                writer.WriteLine($"{returnMaybe} ctx.Runner.Evaluate({funcParamName}({funcArguments}));");
            }
        }
    }

    private static void EmitXmlDocumentation(IndentedTextWriter writer, int parameterCount, bool returnsResult)
    {
        string funcParamName = returnsResult ? "recursiveFunc" : "recursiveAction";
        writer.WriteLine($"/// <summary>");
        writer.Write($"/// Runs a recursive function that");
        if (parameterCount > 0)
        {
            writer.Write($" accepts {s_numberInfo[parameterCount - 1].Numeral} parameter{(parameterCount > 0 ? "s" : "")} and");
        }
        if (returnsResult)
        {
            writer.WriteLine($" returns a result.");
        }
        else
        {
            writer.WriteLine($" does not return a result.");
        }
        writer.WriteLine($"/// </summary>");
        writer.WriteLine($"/// <param name=\"{funcParamName}\">The recursive function to run. It should be an");
        writer.WriteLine($"/// <see langword=\"async\"/> function that returns <see cref=\"RecursiveOp{(returnsResult ? "{TResult}" : "")}\"/>.</param>");
        for (int i = 1; i <= parameterCount; i++)
        {
            writer.WriteLine($"/// <param name=\"arg{i}\">The {s_numberInfo[i - 1].Ordinal} argument to <paramref name=\"{funcParamName}\"/>.</param>");
        }
        writer.WriteLine($"/// <exception cref=\"ArgumentNullException\"><paramref name=\"{funcParamName}\"/> is <see langword=\"null\"/>.</exception>");
    }

    private static IndentationScope EnterBlock(IndentedTextWriter textWriter, string line)
    {
        textWriter.WriteLine(line);
        return new(textWriter);
    }

    private static string GetSourceText()
    {
        StringWriter sw = new();
        IndentedTextWriter writer = new(sw);

        writer.WriteLine("// <auto-generated/>");
        writer.WriteLine("#nullable enable");
        writer.WriteLine();
        writer.WriteLine("using System.Runtime.CompilerServices;");
        writer.WriteLine();
        writer.WriteLine("namespace Recursiont;");
        writer.WriteLine();
        using (EnterBlock(writer, "partial class RecursiveRunner"))
        {
            for (int i = 0; i <= s_numberInfo.Length - 1; i++)
            {
                EmitRunMethod(writer, i, false);
                writer.WriteLine();
                EmitRunMethod(writer, i, true);
                writer.WriteLine();
            }
            EmitRunMethod(writer, s_numberInfo.Length, false);
            writer.WriteLine();
            EmitRunMethod(writer, s_numberInfo.Length, true);
        }

        writer.Flush();
        return sw.ToString();
    }

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource("RecursiveRunner.Run.g.cs", GetSourceText()));
    }

    private readonly struct IndentationScope : IDisposable
    {
        private readonly IndentedTextWriter _textWriter;

        public IndentationScope(IndentedTextWriter textWriter)
        {
            _textWriter = textWriter;
            _textWriter.WriteLine('{');
            _textWriter.Indent++;
        }

        public void Dispose()
        {
            _textWriter.Indent--;
            _textWriter.WriteLine('}');
        }
    }
}
